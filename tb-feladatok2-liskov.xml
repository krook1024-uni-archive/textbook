<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
            A Liskov helyettesítési elv megköveteli, hogy minden osztály legyen
            helyettesíthető egy gyermek osztályával anélkül, hogy a program
            helyes működése megváltozna.
        </para>
        <para>
            Ez az elv egyébként része a <emphasis role="strong">S.O.L.I.D</emphasis>
            alapelveknek, melyet Robert C. Martin, a clean code mozgalom atyja
            alkotott meg. Ezek az alapelvek a kód minőségét hivatottak
            javítani. Hogyha szeretnél erről részletesen olvasni, olvasd
            el ezt a posztot:
            <link xlink:href="https://www.refaktor.hu/tiszta-kod-5-resz-a-s-o-l-i-d-alapelvek/">
            ttps://www.refaktor.hu/tiszta-kod-5-resz-a-s-o-l-i-d-alapelvek/
            </link>.
        </para>
        <caution>
            <title>Módosított kódcsipet</title>
            <para>
                Az alábbi kódcsipetet a fenti blogposztból vettem át.
            </para>
        </caution>
        <para>
            Tekintsük ezt a példát, ahol egy blogmotorral dolgozunk és
            a <classname>BlogPost</classname> osztályt kiegészítjük a
            <classname>VideoBlogPost</classname> osztállyal, amely videók
            megjelenítésére hivatott.
        </para>
        <programlisting language="java">
            <textobject>
                <textdata fileref="./files/liskov/BlogPost.java" />
            </textobject>
        </programlisting>
        <para>
            Amint látszik, a <classname>VideoBlogPost</classname> osztály
            <function>getContent()</function> metódusa felülírja a szülőét,
            méghozzá olyan módon, hogy ha a főprogramban az összes
            <classname>BlogPost</classname> példányt kicserélnék
            <classname>VideoBlogPost</classname> példányra, akkor bizony
            problémába ütköznénk.
        </para>
        <para>
            Bár viszonylag kevés blogmotor íródik C++-ban, lássuk
            ebben a nyelvben is ugyanezt a példát.
        </para>
        <programlisting language="c++">
            <textobject>
                <textdata fileref="./files/liskov/LSP.cc" />
            </textobject>
        </programlisting>
    </section>
    <section>
        <title>Szülő-gyerek</title>
        <para>
            Demonstráljuk c++ és java osztálydefiníción keresztül, hogy az
            ősön keresztül csak az ős üzenetei küldhetők!
        </para>
        <para>
            A feladat azt mutatja meg, hogy nem lehetséges a szülőn keresztül
            olyan metódust meghívnunk, amit a gyermek igen, a szülő viszont
            nem definiált.
        </para>
        <programlisting language="c++">
            <textobject>
                <textdata fileref="./files/liskov/ParentChild.cc" />
            </textobject>
        </programlisting>
        <para>
            Amennyiben megpróbáljuk fordítani a fenti C++ kódot,
            a fordító a következő hibával kilép:
        </para>
        <screen><![CDATA[$ g++ ParentChild.cc -o /dev/null
        ParentChild.cc: In function ‘int main(int, char**)’:
ParentChild.cc:23:13: error: ‘class Szulo’ has no member named ‘echo’
   23 |     szulo2->echo("damn, son. where'd u find dis???");
      |             ^~~~]]>
        </screen>
        <para>
            Hasonló a helyzet Javában is:
        </para>
        <programlisting language="java">
            <textobject>
                <textdata fileref="./files/liskov/ParentChild.java" />
            </textobject>
        </programlisting>

        <screen><![CDATA[$ java ParentChild.java
        ParentChild.java:20: error: cannot find symbol        sz2.echo("ballalalalalala");
           ^
  symbol:   method echo(String)
  location: variable sz2 of type Szulo1 error
error: compilation failed]]>
        </screen>
    </section>
    <section>
        <title>Anti OO</title>
        <para>
            A BBP algoritmussal a Pi hexadecimális kifejtésének a 0.
            pozíciótól számított 10^6, 10^7, 10^8 darab jegyét határozzuk meg
            C, C++, Java és C# nyelveken és vessük össze a futási időket!
        </para>
    </section>
    <section>
        <title>Hello, Android!</title>
        <para>
            Élesszük fel az SMNIST for Humans projektet!
        </para>
    </section>
    <section>
        <title>Ciklomatikus komplexitás</title>
        <para>
            Számoltassuk ki valamelyik programunk ciklomatikus komplexitását!
        </para>
        <para>
            A ciklomatikus komplexitás a forráskódot jellemző tulajdonság, azt
            mondja meg, hogy egy adott programban hány lineárisan független út
            található egy programban. Lefordítva, hogy hány féle képpen mehet a
            vezérlés a program kezdetétől a végéig.
        </para>
        <para>
            Ennek kiszámítását végezhetnénk kézzel, a viszonylag egyszerű
            szabályok mentén, vagy a több tucat kiegészítő segítségével, ami
            minden népszerű IDE-hez létezik.
        </para>
        <para>
            Az IntelliJ IDEA fejlesztői környezetben a
            <filename>Metrics</filename> kiegészítővel számoltam ki az előző
            fejezet <emphasis role="strong"> Homokozó</emphasis> feladatához
            tartozó kód ciklomatikus komplexitását. A végeredmény a
            <filename>v(G)</filename> oszlopban található.
        </para>
        <figure>
            <title>IntelliJ IDEA ciklomatikus komplexitás számoltatás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/ccomplexity.png" width="100%" />
				</imageobject>
			</mediaobject>
		</figure>
    </section>
</chapter>
