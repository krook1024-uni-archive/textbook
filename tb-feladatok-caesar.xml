<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
	</info>

    <section>
		<title><type>double **</type> háromszögmátrix</title>

		<programlisting language="c">
			<textobject>
				<textdata fileref="./files/caesar/doubleharomszog.c"/>
			</textobject>
		</programlisting>

        <para>
			Ebben a példában a C nyelv fő jellegzetességével foglalkozunk,
			ami nem az egyszerűsége, hanem a dinamikus memóriakezelés.
		</para>

		<para>
			Ebben a programban egy olyan példát nézünk meg, ahol létrehozunk
			egy double ** háromszögmátrixot, ami lényegében nem más, mint egy
			kétdimenziós tömb (C-ben a <code>[]</code> jelek használata a
			tömbök kezelésére csupán egy fordító adta kényelem, hogy ne kelljen
			mindig mutató-, és címaritmetikával foglalkozunk).
		</para>
		<para>
			A program úgy működik, hogy elsőnek megadjuk, hogy hányszor
			hányas tömböt szeretnénk létrehozni, és ezt eltároljuk a db változóba.
			Ezután lefoglaljuk magát a hm háromszögmátrixot, és a megértés érdekében
			kiiíratjuk a memóriacímét is (példa lentebb).
			Ezt követően lefoglalunk <code>db</code> darab (esetünkben 5)
			tömböt, amelyek a következő lépésben szintén tartalmazni fognak 5 db
			tömböt, melynek elemeit inicializáljuk (i+j-vel), hogy lássuk, hogy itt
			valóban már adatok jelennek meg, és nem memóracímek.
		</para>

		<programlisting>
<![CDATA[$ gcc doubleharomszog.c -o dm && ./dm
Fő mutató címe: 0x7ffe73a795b0
Lefoglalt 5 double** címe: 0x55deb701c670
Első szint első eleme: 0x55deb701c6a0
[0][0]: 0.000000 [0][1]: 1.000000 [0][2]: 2.000000 [0][3]: 3.000000 [0][4]: 4.000000
[1][0]: 1.000000 [1][1]: 2.000000 [1][2]: 3.000000 [1][3]: 4.000000 [1][4]: 5.000000
[2][0]: 2.000000 [2][1]: 3.000000 [2][2]: 4.000000 [2][3]: 5.000000 [2][4]: 6.000000
[3][0]: 3.000000 [3][1]: 4.000000 [3][2]: 5.000000 [3][3]: 6.000000 [3][4]: 7.000000
[4][0]: 4.000000 [4][1]: 5.000000 [4][2]: 6.000000 [4][3]: 7.000000 [4][4]: 8.000000]]>
		</programlisting>

		<para>
			Tehát a feladat fő tanulsága, hogy a [] jelek valóban csak a
			fordító adta kényelmi funckió. C-ben azt a kifejezést, hogy
			<code language="c">hm[1][1]</code> legalább háromféleképpen
			fejezhetjük ki, melyek a következők:
			<code language="c">(*hm[1]+1)</code>, vagy
			<code language="c">(*(*hm + 1)+1)</code>.

		</para>

	</section>

    <section>
        <title>C EXOR titkosító</title>
		<programlisting language="c">
			<textobject>
				<textdata fileref="./files/caesar/xor_e.c" />
			</textobject>
		</programlisting>

        <para>
        	Az XOR titoksító programunk meglehetősen egyszerűen működik. Az
			argumentumból kiolvassuk a kulcsot majd a <code>while</code>
			ciklusban olvassuk az érkező bementet az úgynevezett
			sztenderd inputon. Majd menézzük a bemenetünk méretetét,
			és ennek a teljes tartalmát "titkosítjuk", azaz
			elvégezzük rajta a bitenkénti XOR utasítást
			<code language="c">buffer[i] ^= key[key_index];</code>).
			Ezután vesszük a buffert és kinyomjuk az úgynevezett
			sztendert outputon. Ez azért jó, mert a felhasználó
			egyszerűen inspektálhatja, vagy fájlba írhatja a kimenetet,
			legalábbis UNIX-jellegű operációs rendszerek alatt.
		</para>
		<para>
			Természetesen ugyanezzel a kóddal és a kulcs ismeretében,
			a generált titkosított állomány vissza is fejthető.
		</para>
	</section>

    <section>
        <title>Java EXOR titkosító</title>
		<programlisting language="java">
			<textobject>
				<textdata fileref="./files/caesar/java/XorEncode.java"/>
			</textobject>
		</programlisting>
		<para>
			A Java egy erősen objektum orientált nyelv [...]
		</para>
	</section>

    <section>
        <title>C EXOR törő</title>
		<para>
			<emphasis>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
			</emphasis>
		</para>
		<para>
			<emphasis role="strong">
				Megoldás forrása:
			</emphasis>
			<link xlink:href="https://raw.githubusercontent.com/krook1024/Bevprog/master/xortores/crack.c">gh/krook1024/Bevprog/master/xortores/crack.c</link>
		</para>

		<para>
			Ez a program csak olyan állományok feltörésére alkalmas,
			amelyeknek a kulcsa csak számokból áll, és 8 karakter
			hosszú. Ezt természetesen a kódban lehet módosítani.
		</para>
		<para>
			A programunk egy bruteforce algoritmust használ, hogy visszafejtse
			a titkosított szöveget. A bemenetet olvasva a program
			meghatározza a szavak hosszát, és amennyiben ez megfelel egy
			bizonyos értékhatárnak, megnézi, hogy előfordulnak-e benne
			a leggyakoribb magyar szavak (a, meg, vagy, van, volt, már, stb...),
			és ha sikerül találni ilyeneket, akkor kiírja a kimenetre.
		</para>
		<para>
			Ebben a példában ismét az OpenMP-t használjuk párhuzamosításra,
			hogy minél gyorsabban végezzünk a töréssel.
		</para>
	</section>

    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
</chapter>
