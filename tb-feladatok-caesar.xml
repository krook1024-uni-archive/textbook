<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
	</info>

    <section>
		<title><type>double **</type> háromszögmátrix</title>

		<programlisting language="c">
			<textobject>
				<textdata fileref="./files/caesar/doubleharomszog.c"/>
			</textobject>
		</programlisting>

        <para>
			Ebben a példában a C nyelv fő jellegzetességével foglalkozunk,
			ami nem az egyszerűsége, hanem a dinamikus memóriakezelés.
			Nézzünk meg egy olyan példát, ahol létrehozunk
			egy double ** háromszögmátrixot, ami lényegében nem más, mint egy
			kétdimenziós tömb (C-ben a <code>[]</code> jelek használata a
			tömbök kezelésére csupán egy fordító adta kényelem, hogy ne kelljen
			mindig mutató-, és címaritmetikával foglalkozunk).
			A különbség itt az lesz, hogy nem mondjuk meg előre, hogy hány
			elemű tömbjeink lesznek, hanem azokat majd dinamikusan
			foglaljuk le.
		</para>

		<para>
			A program úgy működik, hogy elsőnek megadjuk, hogy hányszor
			hányas tömböt szeretnénk létrehozni, és ezt eltároljuk a db változóba.
			Ezután lefoglaljuk magát a hm háromszögmátrixot, és a megértés érdekében
			kiiíratjuk a memóriacímét is (példa lentebb).
			Ezt követően lefoglalunk <code>db</code> darab (esetünkben 5)
			tömböt (ezek lesznek a sorok), amelyek a következő lépésben szintén
			tartalmazni fognak 5 db tömböt (ezek pedig az oszlopok).
		</para>

		<para>
			Egy alsó háromszögmátrix egy olyan mátrix, melyben a főátló felett csupán
			nullák vannak. A programunk egy kvadratikus háromszögmátrixot készít el,
			olyan módon, hogy minden elemét úgy állítjuk be, hogy <code>(i+1)/(j+1)</code>,
			ahol az i a sor	száma, a j pedig az oszlop száma. A +1 azért kell, hogy ne osszunk
			nullával véletlenül se.
		</para>

		<screen>
<![CDATA[$ gcc doubleharomszog.c  && ./a.out
Mutato cime: 0x7fffbc435de0
Sorok tombjenek cime: 0x5567bca69670
Elso sor cime: 0x5567bca696a0
|1.00  0.00  0.00  0.00  0.00  |
|2.00  1.00  0.00  0.00  0.00  |
|3.00  1.00  1.00  0.00  0.00  |
|4.00  2.00  1.00  1.00  0.00  |
|5.00  2.00  1.00  1.00  1.00  |]]>
		</screen>

		<para>
			A feladat tanulsága, hogy a [] jelek valóban csak a
			fordító adta kényelmi funckió. C-ben azt a kifejezést, hogy
			<code language="c">hm[1][1]</code> legalább háromféleképpen
			fejezhetjük ki, melyek a következők:
			<code language="c">(*hm[1]+1)</code>, vagy
			<code language="c">(*(*hm + 1)+1)</code>.
		</para>
	</section>

    <section>
        <title>C EXOR titkosító</title>
		<programlisting language="c">
			<textobject>
				<textdata fileref="./files/caesar/xor_e.c" />
			</textobject>
		</programlisting>

        <para>
        	Az XOR titoksító programunk meglehetősen egyszerűen működik. Az
			argumentumból kiolvassuk a kulcsot majd a <code>while</code>
			ciklusban olvassuk az érkező bementet az úgynevezett
			sztenderd inputon. Majd menézzük a bemenetünk méretetét,
			és ennek a teljes tartalmát "titkosítjuk", azaz
			elvégezzük rajta a bitenkénti XOR utasítást
			<code language="c">buffer[i] ^= key[key_index];</code>).
			Ezután vesszük a buffert és kinyomjuk az úgynevezett
			sztendert outputon. Ez azért jó, mert a felhasználó
			egyszerűen inspektálhatja, vagy fájlba írhatja a kimenetet,
			legalábbis UNIX-jellegű operációs rendszerek alatt.
		</para>

		<para>
			Természetesen ugyanezzel a kóddal és a kulcs ismeretében,
			a generált titkosított állomány vissza is fejthető.
		</para>
	</section>

    <section>
		<title>Java EXOR titkosító</title>
		<programlisting language="java">
			<textobject>
				<textdata fileref="./files/caesar/java/XorEncode.java"/>
			</textobject>
		</programlisting>
		<para>
			A Java egy objektum orientált nyelv, melyet főleg enterprise
			környezetekben használnak, mert jellegénél fogva jól modulálható,
			valamint nincs benne semmiféle memóriakezelés, sokan emiatt hívják
			viccesen memóriakezelés nélküli C-nek is, mely érthető,
			hiszen a két nyelv szintaxisa között valóban vannak hasonlóságok.
		</para>
		<para>
			Ebben a programban is hasonlóan járunk el, mint a C-s változatban,
			az argumentumok közül kiolvassuk a kulcsot, majd a standard inputon
			megjelenő szöveget XOR-ozzuk ezzel a kulccsal, majd a kimeneten
			kiíratjuk a végeredményt.
		</para>
	</section>

    <section>
        <title>C EXOR törő</title>
		<para>
			<emphasis>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
			</emphasis>
		</para>
		<para>
			<emphasis role="strong">
				Megoldás forrása:
			</emphasis>
			<link xlink:href="https://raw.githubusercontent.com/krook1024/Bevprog/master/xortores/crack.c">gh/krook1024/Bevprog/master/xortores/crack.c</link>
		</para>

		<para>
			Ez a program csak olyan állományok feltörésére alkalmas,
			amelyeknek a kulcsa csak számokból áll, és 8 karakter
			hosszú. Ezt természetesen a kódban lehet módosítani.
		</para>
		<para>
			A programunk egy bruteforce algoritmust használ, hogy visszafejtse
			a titkosított szöveget. A bemenetet olvasva a program
			meghatározza a szavak hosszát, és amennyiben ez megfelel egy
			bizonyos értékhatárnak, megnézi, hogy előfordulnak-e benne
			a leggyakoribb magyar szavak (
			<emphasis>a, meg, vagy, van, volt, már, stb...</emphasis>),
			és ha sikerül találni ilyeneket, akkor kiírja a kimenetre.
		</para>
		<para>
			Ebben a példában ismét az OpenMP-t használjuk párhuzamosításra,
			hogy minél gyorsabban végezzünk a töréssel.
		</para>
	</section>

    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
		</para>

        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>
		</para>

        <para>
			Ebben az R programban egy neurális hálót építünk fel.
		</para>

		<para>
			A programot futtatva a program kimenetét vizualizálva kapjuk,
			melyeket png-vé konvertáltam, hogy láthassuk őket.
		</para>

		<!--<screen>
			<textobject>
				<textdata fileref="./files/caesar/r/out" />
			</textobject>
		</screen>-->

		<figure>
			<title>Neurális OR kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./files/caesar/r/Rplots.png" width="3in" />
				</imageobject>
			</mediaobject>
		</figure>

		<figure>
			<title>Neurális OR, AND kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./files/caesar/r/Rplots1.png" width="3in" />
				</imageobject>
			</mediaobject>
		</figure>

		<figure>
			<title>Neurális EXOR kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./files/caesar/r/Rplots2.png" width="3.5in" />
				</imageobject>
			</mediaobject>
		</figure>

		<figure>
			<title>Neurális OR kapu</title>
			<mediaobject>
				<imageobject>
					<imagedata fileref="./files/caesar/r/Rplots3.png" width="3.5in" />
				</imageobject>
			</mediaobject>
		</figure>
	</section>

    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
		</para>

        <para>
            Megoldás videó:
		</para>

        <para>
            Megoldás forrása:
		</para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
</chapter>
