<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
    </info>
    <section>
        <title>OO szemlélet</title>
        <para>
			A módosított polártranszformációs normális generátor beprogramozása
			Java nyelven. Mutassunk rá, hogy a mi természetes saját megoldásunk
			(az algoritmus egyszerre két normálist állít elő, kell egy
			példánytag, amely a nem visszaadottat tárolja és egy logikai tag,
			hogy van-e tárolt vagy futtatni kell az algot.) és az OpenJDK,
			Oracle JDK-ban a Sun által adott OO szervezés ua.!
        </para>
		<para>
            https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf (16-22 fólia)
        </para>
        <para>
			Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó:
			source/labor/polargen)
        </para>
        <para>
            A megoldás forrása:
        </para>
        <programlisting language="java">
            <textobject>
                <textdata fileref="./files/arroway/PolarGen.java" />
            </textobject>
        </programlisting>
    </section>
    <section>
		<title>Homokozó</title>
        <caution>
            <title>Tutorált</title>
            <para>
                Ebben a feladatban tutorált Tóth Attila.
            </para>
        </caution>
        <para>
			Írjuk át az első védési programot (LZW binfa) C++ nyelvről Java
			nyelvre, ugyanúgy működjön! Mutassunk rá, hogy gyakorlatilag a
			pointereket és referenciákat kell kiirtani és minden máris működik
			(erre utal a feladat neve, hogy Java-ban minden referencia, nincs
			választás, hogy mondjuk egy attribútum pointer, referencia vagy
			tagként tartalmazott legyen).
        </para>
        <para>
			Miután már áttettük Java nyelvre, tegyük be egy Java Servletbe és a
			böngészőből GET-es kéréssel (például a böngésző címsorából) kapja
			meg azt a mintát, amelynek kiszámolja az LZW binfáját!
		</para>
		<para>
			Megoldása forrása: <link
				xlink:href="https://github.com/krook1024/LZWBinFa-Servlet">https://github.com/krook1024/LZWBinFa-Servlet</link>
		</para>
		<para>
			Általában nem vagyok híve a fejlesztői környezeteknek, amit lehet,
			és egyszerűbb projekt, igyekszem puszta Vim-ben írni. Ennek
			ellenére a megoldást az IntelliJ IDEA fejlesztői környezetben
			készítettem el, hiszen ennek a környezetnek számos kényelmi
			funkciója van.
		</para>
		<para>
			A forrásokat a repón belül a
			<filename>src/com/krook/binfa</filename> mappában találhatjuk meg.
			Itt van a program lelke, az <filename>LZWBinFa</filename> osztály,
			valamint a <filename>BinFaServlet</filename> osztály.
		</para>
		<para>
			A <filename>BinFaServlet</filename> osztály végzi a kommunikációt a
			klienssel, a <filename>javax.servlet</filename> könyvtárait
			felhasználva. Az általunk írt osztály kiterjeszti a
			<filename>HttpServlet</filename> osztályt, valamint felülírja a
			<filename>doPost</filename> és <filename>doGet</filename>
			metódusokat. Utóbbiban történik a lényeges számítás. Lényegében egy
			az egyben ki lehet másolni az előző felvonásban taglalt C++
			programból a megfelelő I/O részeket és ide elhelyezni.
		</para>
		<para>
			A <filename>LZWBinFa</filename> osztály pedig magát a bináris fát építi
			fel a megszokott módon. A forráskód egy az egyben az előző felvonásban
			tárgyalt C++ verzió átirata, a pointerek nélkül, melyek Javában nem léteznek.
		</para>
        <figure>
            <title>LZWBinFa generátor böngészős változata</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/binfa_1.png" width="100%" />
				</imageobject>
			</mediaobject>
		</figure>
		<figure>
			<title>LZWBinFa generátor böngészős változatának kimenete</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./pictures/binfa_2.png" width="100%" />
                </imageobject>
			</mediaobject>
		</figure>
    </section>
    <section>
        <title>"Gagyi"</title>
        <para>
            Az ismert formális
            <code language="C"><![CDATA[while (x <= t && x >= t && t != x);]]></code>
			tesztkérdéstípusra adj a szokásosnál (miszerint x, t az egyik
			esetben az objektum által hordozott érték, a másikban meg az
			objektum referenciája) "mélyebb" választ, írj Java példaprogramot
			mely egyszer végtelen ciklus, más x, t értékekkel meg nem! A példát
			építsd a JDK Integer.java forrására3, hogy a 128-nál inkluzív
			objektum
        </para>
    </section>
    <section>
        <title>Yoda</title>
        <para>
			Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll,
			ha nem követjük a Yoda conditions-t!
			https://en.wikipedia.org/wiki/Yoda_conditions
        </para>
        <para>
            Gyakran előforduló hiba, hogy értékadó utasítást írunk le az if
            szerkezet fejében összehasonlítás helyett. A Yoda conditions
            használata erre kínál megoldás, miszerint fordított sorrendben
            kell megszoknunk a programozást, így ha véletlen egy = jellel
            kevesebbet írnánk, az kiderül fordítási időben, és nem kell
            futásidőig várni, hogy a hiba felüsse a fejét.
        </para>
        <para>
            Ha az alábbi programot próbáljuk fordítani, meg is kapjuk a
            hibánkat, ismét, fordítási időben.
        </para>
        <programlisting language="java">
            <textobject>
                <textdata fileref="./files/arroway/Yoda.java" />
            </textobject>
        </programlisting>
    </section>
    <section>
        <title>Kódolás from scratch </title>
		<para>
			Induljunk ki ebből a tudományos közleményből:
			http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbp-alg.pdf és csak
			ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus
			megvalósítását!
        </para>
        <para>
			Megoldás forrása: <link
				xlink:href="https://github.com/krook1024/BBP">https://github.com/krook1024/BBP</link>
        </para>
        <para>
			A BBP algoritmus a pí jegyeinek gyors kiszámítására született
			algoritmus.
        </para>
    </section>
</chapter>
